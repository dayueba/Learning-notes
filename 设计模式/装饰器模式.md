# 装饰器模式

## 什么是装饰器模式
动态地给一个对象增加一些额外的职责, 就扩展对象来说, 装饰模式比生成子类的方式更加灵活

## 装饰器修饰函数
装饰器的作用: 包装一个函数,并改变(扩展)它的行为
```
# demo
def logger(func):
    def log_time_cost(*args, **kwargs): # 包装函数
        print("start time: " + str(datetime.now()))
        func(*args, **kwargs)
        print("end time: " + str(datetime.now()))

    return log_time_cost

```

## 装饰器修饰类
装饰器可以是一个类(需要实现__call__), 也可以修饰类
```
# demo
class ClassDecorator:
    """类装饰器, 记录一个类被实例化的次数"""

    def __init__(self, func):
        self.__numOfCall = 0
        self.__func = func

    def __call__(self, *args, **kwargs):
        self.__numOfCall += 1
        obj = self.__func(*args, **kwargs)
        print("创建{}的第{}个实例:{}".format(self.__func.__name__, self.__numOfCall, id(obj)))
        return obj

```

## 模型说明
1. 设计要点
    - 可以灵活的给一个对象增加职责或者扩展功能
    - 可以增加多个修饰
    - 装饰的顺序不同, 可能产生不同的效果

2. 优缺点
    - 优点
        1. 使用装饰模式来实现扩展比使用继承更加灵活, 它可以在不创造更多子类的情况下,将对象的功能加以扩展
        2. 可以动态的给一个对象扩展功能
        3. 可以用不同的修饰器进行多重装饰, 顺序不同, 效果也有可能不同
        4. 装饰类和被装饰类可以独立发展, 不会相互耦合, 装饰模式相当于继承的一个替代模式
    - 缺点
        1. 与继承相比, 用装饰模式容易出错,排错也更加困难, 特别是多重修饰的对象

3. 装饰模式和python装饰器的区别和联系
    - 区别点
        - 装饰模式
            1. 面向对象
            2. 修饰的是某个类中的指定方法
            3. 只对修饰的这一个对象起效

        - Python装饰器
            1. 函数式编程思想, 面向过程
            2. 修饰一个函数, 也可以修饰一个类
            3. 对函数的所有调用, 类的所有实例有效
    - 联系
        - 都是为了具有更好的扩展性, 以及不需要做太多代码变动情况下, 增加额外的功能


## 应用场景
1. 有大量独立的扩展, 为支持每一种组合将产生大量的子类, 使得子类数目呈爆照性增长
2. 需要动态的增加或者撤销功能时
3. 不能用生成子类的方法进行扩充时

